package proxy

import (
	"context"
	"fmt"
	"github.com/luraproject/lura/v2/config"
	pContext "github.com/luraproject/lura/v2/context"
	"github.com/luraproject/lura/v2/encoding"
	"github.com/luraproject/lura/v2/transport/http/client"
	"net/http"
	"strconv"
	"strings"
)

func NewInternalProxy(remote *config.Backend, decode encoding.Decoder) Proxy {
	return NewInternalProxyWithHTTPExecutor(remote, decode)
}

func NewInternalProxyWithHTTPExecutor(remote *config.Backend, dec encoding.Decoder) Proxy {
	if remote.Encoding == encoding.NOOP {
		return NewInternalProxyDetailed(remote, client.NoOpHTTPStatusHandler, NoOpHTTPResponseParser)
	}

	ef := NewEntityFormatter(remote)
	rp := DefaultHTTPResponseParserFactory(HTTPResponseParserConfig{dec, ef})
	return NewInternalProxyDetailed(remote, client.GetHTTPStatusHandler(remote), rp)
}

func NewInternalProxyDetailed(backend *config.Backend, ch client.HTTPStatusHandler, rp HTTPResponseParser) Proxy {
	return func(ctx context.Context, request *Request) (*Response, error) {
		//ctx + request >> gin.Context
		//ginCtx := &gin.Context{Request: request}
		//call func(c *gin.Context)
		//pContext.Handlers[backend.URLPattern](ginCtx)
		//parse
		//return rp(ctx, ginCtx.)
		fmt.Println("***************")
		fmt.Println(ctx)
		fmt.Println("***************")
		fmt.Println(request)
		fmt.Println("***************")

		//httpRequest := &http.Request{
		//	Method:     request.Method,
		//	URL:        request.URL,
		//	Form:       request.Query,
		//	PostForm:   request.Query,
		//	RequestURI: request.Path,
		//	Body:       request.Body,
		//	Header:     request.Headers,
		//}

		requestToBakend, err := http.NewRequest(strings.ToTitle(request.Method), request.URL.String(), request.Body)
		if err != nil {
			return nil, err
		}
		requestToBakend.Header = make(map[string][]string, len(request.Headers))
		for k, vs := range request.Headers {
			tmp := make([]string, len(vs))
			copy(tmp, vs)
			requestToBakend.Header[k] = tmp
		}
		if request.Body != nil {
			if v, ok := request.Headers["Content-Length"]; ok && len(v) == 1 && v[0] != "chunked" {
				if size, err := strconv.Atoi(v[0]); err == nil {
					requestToBakend.ContentLength = int64(size)
				}
			}
		}

		//ginCtx := &gin.Context{
		//	Request: requestToBakend,
		//}
		//c, _ := gin.CreateTestContext(httptest.NewRecorder())
		//c.Request = requestToBakend

		//httpRequest := &http.Request{
		//	Method:     request.Method,
		//	URL:        request.URL,
		//	Form:       request.Query,
		//	PostForm:   request.Query,
		//	RequestURI: request.Path,
		//	Body:       request.Body,
		//	Header:     request.Headers,
		//}
		//c := &gin.Context{Request: httpRequest}

		pContext.Handlers[backend.URLPattern](c)

		//resp, err := re(ctx, requestToBakend)
		resp := c.Request.Response
		if requestToBakend.Body != nil {
			requestToBakend.Body.Close()
		}

		select {
		case <-ctx.Done():
			return nil, ctx.Err()
		default:
		}
		if err != nil {
			return nil, err
		}

		resp, err = ch(ctx, resp)
		if err != nil {
			if t, ok := err.(responseError); ok {
				return &Response{
					Data: map[string]interface{}{
						fmt.Sprintf("error_%s", t.Name()): t,
					},
					Metadata: Metadata{StatusCode: t.StatusCode()},
				}, nil
			}
			return nil, err
		}

		return rp(ctx, resp)
	}
}
